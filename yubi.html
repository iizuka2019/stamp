<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>両手指認識ハンドジェスチャープロトタイプ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f4f8;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px; /* canvasのサイズに合わせる */
            height: 480px;   /* canvasのサイズに合わせる */
            margin: 0 auto;
            overflow: hidden;
            border-radius: 8px;
            border: 1px solid #ccc; /* 確認用ボーダー */
        }
        #video { /* video要素は非表示なので、スタイルはほぼ影響なし */
            display: none; 
        }
        #canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            /* transform: scaleX(-1); */ /* selfieMode:true を使うのでCSSでの反転は不要 */
        }
        .controls {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            gap: 15px;
        }
        button {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .status {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 5px solid #3498db;
        }
        .gesture-info {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        .hand-info {
            width: 45%;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 5px solid #27ae60;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 18px;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>両手指認識ハンドジェスチャープロトタイプ</h1>
        
        <div class="controls">
            <button id="startBtn" disabled>カメラ開始</button>
            <button id="stopBtn" disabled>停止</button>
        </div>
        
        <div class="video-container">
            <video id="video" playsinline></video> <!-- style="display: none;" はJS側で制御するなら不要かも -->
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="loading" class="loading">MediaPipeモデルを読み込み中...</div>
        
        <div class="gesture-info">
            <div class="hand-info">
                <h3>左手情報</h3>
                <div id="leftHandInfo">未検出</div>
                <div id="leftHandGesture">ジェスチャー: なし</div>
            </div>
            <div class="hand-info">
                <h3>右手情報</h3>
                <div id="rightHandInfo">未検出</div>
                <div id="rightHandGesture">ジェスチャー: なし</div>
            </div>
        </div>
        
        <div class="status">
            <h3>状態:</h3>
            <div id="status">カメラが停止しています</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const loadingDiv = document.getElementById('loading');
        const leftHandInfo = document.getElementById('leftHandInfo');
        const rightHandInfo = document.getElementById('rightHandInfo');
        const leftHandGesture = document.getElementById('leftHandGesture');
        const rightHandGesture = document.getElementById('rightHandGesture');
        
        let hands;
        let camera;
        let isRunning = false;

        function onResults(results) {
            if (!isRunning) return; // 停止後に結果が届く場合があるため

            if (canvasElement.width !== results.image.width) {
                canvasElement.width = results.image.width;
            }
            if (canvasElement.height !== results.image.height) {
                canvasElement.height = results.image.height;
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // カメラ映像を描画 (results.imageはselfieMode:trueにより既に反転済み)
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            let userLeftHandLandmarks = null;
            let userRightHandLandmarks = null;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const cameraHandedness = results.multiHandedness[i].label; 
                    // selfieMode:true のため、カメラの'Left'がユーザーの右手、'Right'がユーザーの左手
                    const userHandedness = cameraHandedness === 'Left' ? 'Right' : 'Left';

                    // ユーザーの左手(UI上)を緑、右手(UI上)を赤で描画
                    const drawColor = userHandedness === 'Left' ? '#00FF00' : '#FF0000'; 
                    
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: drawColor, lineWidth: 3});
                    drawLandmarks(canvasCtx, landmarks, {color: drawColor, lineWidth: 1, radius: 5});

                    if (userHandedness === 'Left') {
                        userLeftHandLandmarks = landmarks;
                    } else { 
                        userRightHandLandmarks = landmarks;
                    }
                }
            }

            if (userLeftHandLandmarks) {
                const gesture = detectGesture(userLeftHandLandmarks);
                leftHandInfo.textContent = `検出: ${userLeftHandLandmarks.length}点`;
                leftHandGesture.textContent = `ジェスチャー: ${gesture}`;
            } else {
                leftHandInfo.textContent = '未検出';
                leftHandGesture.textContent = 'ジェスチャー: なし';
            }
            
            if (userRightHandLandmarks) {
                const gesture = detectGesture(userRightHandLandmarks);
                rightHandInfo.textContent = `検出: ${userRightHandLandmarks.length}点`;
                rightHandGesture.textContent = `ジェスチャー: ${gesture}`;
            } else {
                rightHandInfo.textContent = '未検出';
                rightHandGesture.textContent = 'ジェスチャー: なし';
            }
            canvasCtx.restore();
        }
        
        async function initializeMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
                selfieMode: true // trueに設定
            });
            
            hands.onResults(onResults);
            
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    if (!hands) return; // handsが初期化されるまで待つ
                    await hands.send({image: videoElement});
                },
                width: 640, 
                height: 480 
            });

            videoElement.style.display = 'none'; // camera_utilsが制御するのでvideo要素は非表示

            loadingDiv.style.display = 'none';
            statusDiv.textContent = 'モデル準備完了！カメラを開始してください。';
            startBtn.disabled = false;
        }
        
        function detectGesture(landmarks) {
            const fingertips = [4, 8, 12, 16, 20];
            // const secondJoints = [3, 7, 11, 15, 19]; // Y座標比較ならMCPの方が安定するかも
            const mcpJoints = [2, 5, 9, 13, 17]; // 親指(2), 人差し指(5), 中指(9), 薬指(13), 小指(17)
            
            let extendedFingers = 0;

            // 人差し指から小指 (i=1 to 4)
            for (let i = 1; i < fingertips.length; i++) { 
                const fingertip = landmarks[fingertips[i]];
                const mcpJoint = landmarks[mcpJoints[i]];
                if (fingertip.y < mcpJoint.y) { // Y座標は画面上が小さい
                    extendedFingers++;
                }
            }
            
            // 親指
            const thumbTip = landmarks[fingertips[0]]; // 4
            const thumbMcp = landmarks[mcpJoints[0]]; // 2
            // 親指がMCP関節より「上」にあるか、または手首(0)に対して開いているかで判断
            // ここでは単純にY座標で比較
            if (thumbTip.y < thumbMcp.y) {
                 extendedFingers++;
            }
            
            if (extendedFingers === 5) return '開いた手';
            if (extendedFingers === 0) return '握りこぶし';
            
            // ピースサインの判定 (人差し指と中指が伸びていて、他が曲がっている)
            const indexTip = landmarks[fingertips[1]];
            const indexMcp = landmarks[mcpJoints[1]];
            const middleTip = landmarks[fingertips[2]];
            const middleMcp = landmarks[mcpJoints[2]];
            const ringTip = landmarks[fingertips[3]];
            const ringMcp = landmarks[mcpJoints[3]];
            const pinkyTip = landmarks[fingertips[4]];
            const pinkyMcp = landmarks[mcpJoints[4]];

            if (extendedFingers === 2 && 
                indexTip.y < indexMcp.y && 
                middleTip.y < middleMcp.y &&
                !(thumbTip.y < thumbMcp.y) && // 親指は曲がっている
                !(ringTip.y < ringMcp.y) &&   // 薬指は曲がっている
                !(pinkyTip.y < pinkyMcp.y)    // 小指は曲がっている
            ) return 'ピース';

            // 指差しの判定 (人差し指のみ伸びている)
             if (extendedFingers === 1 && 
                indexTip.y < indexMcp.y &&
                !(thumbTip.y < thumbMcp.y) &&   // 親指は曲がっている
                !(middleTip.y < middleMcp.y) && // 中指は曲がっている
                !(ringTip.y < ringMcp.y) &&     // 薬指は曲がっている
                !(pinkyTip.y < pinkyMcp.y)      // 小指は曲がっている
            ) return '指差し';
            
            return `指 ${extendedFingers} 本`;
        }
        
        async function startDetection() {
            if (isRunning || !camera) return; // cameraが未初期化なら何もしない
            
            try {
                await camera.start();
                isRunning = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                statusDiv.textContent = '検出中...両手を画面に向けてください';
            } catch (error) {
                console.error('検出の開始に失敗しました:', error);
                isRunning = false;
                statusDiv.textContent = 'エラー: 検出の開始に失敗しました。';
            }
        }
        
        function stopDetection() {
            if (!isRunning && !camera) return;
            
            // camera.stop() が camera_utils にあればそれを使うのが理想
            // ない場合は、フレーム処理を止めるか、ストリームを止める
            isRunning = false; // これで onResults 内の処理がスキップされる
            
            const stream = videoElement.srcObject;
            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusDiv.textContent = '停止しました';
            leftHandInfo.textContent = '未検出';
            rightHandInfo.textContent = '未検出';
            leftHandGesture.textContent = 'ジェスチャー: なし';
            rightHandGesture.textContent = 'ジェスチャー: なし';
        }
        
        startBtn.addEventListener('click', startDetection);
        stopBtn.addEventListener('click', stopDetection);
        
        window.addEventListener('load', async () => {
            try {
                await initializeMediaPipe();
            } catch (error) {
                console.error("初期化エラー:", error);
                loadingDiv.textContent = '初期化エラーが発生しました。コンソールを確認してください。';
                statusDiv.textContent = 'エラー: 初期化に失敗しました。';
            }
        });
    </script>
</body>
</html>
