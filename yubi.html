<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>両手指認識ハンドジェスチャープロトタイプ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f4f8;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            overflow: hidden;
            border-radius: 8px;
        }
        #video {
            width: 100%;
            height: auto;
            transform: scaleX(-1); /* ミラー表示 */
            background-color: #333;
        }
        #canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* ミラー表示 */
        }
        .controls {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            gap: 15px;
        }
        button {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .status {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 5px solid #3498db;
        }
        .gesture-info {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        .hand-info {
            width: 45%;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 5px solid #27ae60;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 18px;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>両手指認識ハンドジェスチャープロトタイプ</h1>
        
        <div class="controls">
            <button id="startBtn">カメラ開始</button>
            <button id="stopBtn" disabled>停止</button>
        </div>
        
        <div class="video-container">
            <video id="video" playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="loading" class="loading">MediaPipeモデルを読み込み中...</div>
        
        <div class="gesture-info">
            <div class="hand-info">
                <h3>左手情報</h3>
                <div id="leftHandInfo">未検出</div>
                <div id="leftHandGesture">ジェスチャー: なし</div>
            </div>
            <div class="hand-info">
                <h3>右手情報</h3>
                <div id="rightHandInfo">未検出</div>
                <div id="rightHandGesture">ジェスチャー: なし</div>
            </div>
        </div>
        
        <div class="status">
            <h3>状態:</h3>
            <div id="status">カメラが停止しています</div>
        </div>
    </div>

    <!-- MediaPipe Hands -->
    <!-- 以下のCDNスクリプトは、グローバルに `Hands` オブジェクトを提供します -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mediapipe/0.7.5/hands_solution_simd_wasm_bin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mediapipe/0.7.5/hands_solution_packed_assets_loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mediapipe/0.7.5/hands.js"></script>

    <script>
        // DOM要素
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const loadingDiv = document.getElementById('loading');
        const leftHandInfo = document.getElementById('leftHandInfo'); // ユーザーから見て左手
        const rightHandInfo = document.getElementById('rightHandInfo'); // ユーザーから見て右手
        const leftHandGesture = document.getElementById('leftHandGesture');
        const rightHandGesture = document.getElementById('rightHandGesture');
        
        let handsModel;
        let isModelReady = false;
        let isRunning = false;
        let stream;
        
        // MediaPipe Handsの読み込み
        async function loadModel() {
            try {
                // ★★★ 修正点: 実際のMediaPipe Handsを初期化 ★★★
                handsModel = new Hands({ // `Hands` はCDNの `hands.js` からグローバルに提供される
                    locateFile: (file) => {
                        // MediaPipeが必要とするWASMファイルなどのパスを指定
                        // このCDN構成の場合、ファイルは同じベースパスにあると期待される
                        console.log(`MediaPipe wants to locate: ${file}`);
                        return `https://cdnjs.cloudflare.com/ajax/libs/mediapipe/0.7.5/${file}`;
                    }
                });

                // モデルのオプション設定や結果コールバックは、startDetection時、またはここで設定
                handsModel.onResults((results) => {
                    if (!isRunning) return; // 停止後に結果が届く場合があるのでチェック
                    drawResults(results);
                });
                
                isModelReady = true;
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'モデル準備完了！カメラを開始してください。';
                startBtn.disabled = false; // モデル準備完了で開始ボタンを有効化

            } catch (error) {
                console.error('モデルの読み込みに失敗しました:', error);
                statusDiv.textContent = 'エラー: モデルの読み込みに失敗しました。';
                loadingDiv.textContent = 'エラー: MediaPipeモデルを読み込めませんでした。コンソールで詳細を確認してください。';
            }
        }
        
        // カメラのセットアップ (変更なし)
        async function setupCamera() {
            if (!isModelReady) {
                alert('モデルがまだ読み込まれていません。しばらくお待ちください。');
                return;
            }
            
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve(video);
                    };
                });
            } catch (error) {
                console.error('カメラの設定に失敗しました:', error);
                statusDiv.textContent = 'エラー: カメラへのアクセスが拒否されました。';
                throw error;
            }
        }
        
        // 手の検出を開始
        async function startDetection() {
            if (isRunning) return;
            if (!isModelReady) { // 追加: モデルが準備できていない場合は何もしない
                statusDiv.textContent = 'モデルの準備ができていません。しばらくお待ちください。';
                return;
            }
            isRunning = true;
            
            try {
                await setupCamera();
                
                handsModel.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                // onResultsはloadModelで設定済みなのでここでは不要
                
                detectHands();
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                statusDiv.textContent = '検出中...両手を画面に向けてください';
            } catch (error) {
                console.error('検出の開始に失敗しました:', error);
                isRunning = false;
                statusDiv.textContent = 'エラー: 検出の開始に失敗しました。';
                stopDetection(); // エラー発生時は停止処理を呼ぶ
            }
        }
        
        // 手の検出ループ
        async function detectHands() {
            if (!isRunning) return;
            
            try {
                // ★★★ 修正点: handsModel.send は Promise を返さないため await は不要 ★★★
                if (video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) { // ビデオデータがあるか確認
                   handsModel.send({ image: video });
                }
                requestAnimationFrame(detectHands);
            } catch (error) {
                console.error('手の検出中にエラーが発生しました:', error);
                statusDiv.textContent = 'エラー: 手の検出中にエラーが発生しました。';
                stopDetection();
            }
        }
        
        // 結果の描画
        function drawResults(results) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let userLeftHandLandmarks = null;  // ユーザーから見て左手
            let userRightHandLandmarks = null; // ユーザーから見て右手
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const cameraHandedness = results.multiHandedness[i].label; // "Left" or "Right" (カメラから見た手)
                    
                    // ★★★ 修正点: ミラー表示のため、ユーザー視点の左右に変換 ★★★
                    const userHandedness = cameraHandedness === 'Left' ? 'Right' : 'Left';
                    
                    // ユーザーの左手を緑、右手を赤で描画
                    const color = userHandedness === 'Left' ? '#00FF00' : '#FF0000'; 
                    
                    drawHandLandmarks(landmarks, color);
                    
                    if (userHandedness === 'Left') {
                        userLeftHandLandmarks = landmarks;
                    } else { // userHandedness === 'Right'
                        userRightHandLandmarks = landmarks;
                    }
                }
            }
            
            // 左手情報 (ユーザーから見て左手)
            if (userLeftHandLandmarks) {
                const gesture = detectGesture(userLeftHandLandmarks); // handednessは今のロジックでは不要
                leftHandInfo.textContent = `検出: ${userLeftHandLandmarks.length}点`;
                leftHandGesture.textContent = `ジェスチャー: ${gesture}`;
            } else {
                leftHandInfo.textContent = '未検出';
                leftHandGesture.textContent = 'ジェスチャー: なし';
            }
            
            // 右手情報 (ユーザーから見て右手)
            if (userRightHandLandmarks) {
                const gesture = detectGesture(userRightHandLandmarks); // handednessは今のロジックでは不要
                rightHandInfo.textContent = `検出: ${userRightHandLandmarks.length}点`;
                rightHandGesture.textContent = `ジェスチャー: ${gesture}`;
            } else {
                rightHandInfo.textContent = '未検出';
                rightHandGesture.textContent = 'ジェスチャー: なし';
            }
        }
        
        // 手のランドマークを描画 (変更なし)
        function drawHandLandmarks(landmarks, color) {
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // 親指
                [0, 5], [5, 6], [6, 7], [7, 8], // 人差し指 (線[0,5]は手首-指付根)
                [0, 9], [9, 10], [10, 11], [11, 12], // 中指 (線[0,9]は手首-指付根)
                [0, 13], [13, 14], [14, 15], [15, 16], // 薬指 (線[0,13]は手首-指付根)
                [0, 17], [17, 18], [18, 19], [19, 20], // 小指 (線[0,17]は手首-指付根)
                // 手のひら (MediaPipe標準とは少し異なるが、手首から各指の付け根、付け根同士)
                [5, 9], [9, 13], [13, 17] // 指の付け根同士。場合によっては[17,0]で閉じることも
            ];
            
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.strokeStyle = color;
            
            for (const connection of connections) { // 修正: `connections`の各要素は配列なので、分割代入ではなく直接使う
                const startIdx = connection[0];
                const endIdx = connection[1];
                // ランドマークが存在するかチェック (稀にインデックス外参照が起こる可能性を考慮)
                if (landmarks[startIdx] && landmarks[endIdx]) {
                    const startPoint = landmarks[startIdx];
                    const endPoint = landmarks[endIdx];
                    
                    ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
                    ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
                }
            }
            ctx.stroke();
            
            for (const point of landmarks) {
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.arc(
                    point.x * canvas.width, 
                    point.y * canvas.height, 
                    5, 0, 2 * Math.PI
                );
                ctx.fill();
            }
        }
        
        // ジェスチャーの検出（単純な例 - 変更なし、ただし改善の余地あり）
        function detectGesture(landmarks) {
            const fingertips = [4, 8, 12, 16, 20];
            const secondJoints = [3, 7, 11, 15, 19]; // 親指はIP関節, 他はPIP関節に近い
            
            let extendedFingers = 0;
            // 人差し指から小指まで
            for (let i = 1; i < fingertips.length; i++) { 
                const fingertip = landmarks[fingertips[i]];
                const pipJoint = landmarks[landmarks[0].y > landmarks[5].y ? fingertips[i]-1 : fingertips[i]-2]; // MCP関節 or PIP関節 (より手首に近い方)
                const mcpJoint = landmarks[fingertips[i]-2] // MCP関節
                
                // 指先がMCP関節よりも「上」にあれば伸びていると判断 (Y軸は下が正なので、Y座標が小さい)
                if (fingertip.y < mcpJoint.y) {
                     // さらに、指先がPIP関節よりも上なら確実に伸びている
                    if (fingertip.y < pipJoint.y) {
                         extendedFingers++;
                    } else { 
                        // 指先がPIPとMCPの間の場合、少し曲がっているが、ここでは伸ばしているとカウントする例
                        // extendedFingers++; // 必要に応じて調整
                    }
                }
            }
            
            // 親指のチェック
            const thumbTip = landmarks[fingertips[0]]; // 4
            const thumbIp = landmarks[secondJoints[0]]; // 3 (IP関節)
            const thumbMcp = landmarks[2]; // MCP関節
            const wrist = landmarks[0];

            // 親指が伸びているか（他の指に比べて相対的にどうか、または手首からの角度など）
            // 例: 親指の先端がIP関節より「上」かつ、IP関節がMCP関節より「上」
            // または、親指の先端が人差し指の付け根(5)より横に離れているなど
            // ここでは元のロジック（横への広がり）を維持しつつ、少し改善
            // 親指の先端がIP関節よりy座標が小さい（上に伸びている）かつ、x座標も十分に離れている（開いている）
            if (thumbTip.y < thumbIp.y && Math.abs(thumbTip.x - landmarks[5].x) > 0.04) { // landmarks[5]は人差し指の付け根
                 extendedFingers++;
            } else if (Math.abs(thumbTip.x - thumbIp.x) > 0.05) { // 元の横方向の広がり判定
                 extendedFingers++;
            }

            if (extendedFingers === 5) return '開いた手 (パー)';
            if (extendedFingers === 0) return '握りこぶし (グー)';
            if (extendedFingers === 2) {
                // 人差し指と中指が伸びているかチェック (ピースサイン)
                const indexFingerTip = landmarks[8];
                const indexFingerMcp = landmarks[5];
                const middleFingerTip = landmarks[12];
                const middleFingerMcp = landmarks[9];
                if (indexFingerTip.y < indexFingerMcp.y && middleFingerTip.y < middleFingerMcp.y) {
                     // 親指と小指が曲がっていることも確認するとより正確
                    const pinkyTip = landmarks[20];
                    const pinkyMcp = landmarks[17];
                    if ( !(thumbTip.y < thumbIp.y) && !(pinkyTip.y < pinkyMcp.y)) { // 親指と小指が伸びていない
                        return 'ピース';
                    }
                }
            }
            if (extendedFingers === 1) {
                 // 人差し指だけが伸びているか (指差し)
                const indexFingerTip = landmarks[8];
                const indexFingerMcp = landmarks[5];
                if (indexFingerTip.y < indexFingerMcp.y) {
                    let otherFingersBent = true;
                    for (let i = 2; i < fingertips.length; i++) { // 中指、薬指、小指
                        if (landmarks[fingertips[i]].y < landmarks[fingertips[i]-2].y) {
                            otherFingersBent = false;
                            break;
                        }
                    }
                    if (otherFingersBent && !(thumbTip.y < thumbIp.y) ) { // 親指も曲がっている
                         return '指差し';
                    }
                }
            }
            
            return `指 ${extendedFingers} 本`; // 不明な場合は伸ばした指の数を返す
        }
        
        // 検出を停止 (変更なし)
        function stopDetection() {
            if (!isRunning) return;
            isRunning = false;
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusDiv.textContent = '停止しました';
            leftHandInfo.textContent = '未検出';
            rightHandInfo.textContent = '未検出';
            leftHandGesture.textContent = 'ジェスチャー: なし';
            rightHandGesture.textContent = 'ジェスチャー: なし';
        }
        
        startBtn.addEventListener('click', startDetection);
        stopBtn.addEventListener('click', stopDetection);
        
        window.addEventListener('load', loadModel);
    </script>
</body>
</html>
